~/research/github/Draco_Dark_OSPM/OSPM/OSPM/OSPM_pkg/pkg_v1$
# Julia environment check
julia --startup-file=no -e 'include("ospm_physics_spherical.jl"); using .OSPMPhysicsSpherical; println("Loaded OK")'



next physics upgrades, in order of importance:

Introduce φ evolution

	Add φ to the state vector

	Integrate φ̇ = Lz / (r² sin²θ)

	Keep everything else unchanged

True observer LOS

	Define observer direction once

	Project velocity vector fully: \phi' = Lz / (r^2sin^2\theta)

	No more axisymmetric shortcut

	Radial bin edges instead of centers

	Removes the last source of bias

	Makes σ² estimator statistically clean

Orbit weight regularization

	Prevents single-orbit dominance

	Stabilizes NNLS






OSPM – How to Run (current Python stack)
=======================================

This is the profile-based, spherical OSPM pipeline. It replaces the legacy
Fortran driver and grid search while keeping the physics explicit and auditable.

----------------------------------------------------------------
FILES AND WHAT THEY DO
----------------------------------------------------------------

OSPM_Config.py
- Galaxy-specific configuration only.
- Defines parameter names, bounds, initial theta, paths, and run limits.
- No physics and no execution logic.
- One config file per galaxy.

OSPM_Control.py
- Loads the config and prepares runtime metadata.
- Creates the daemon deck CSV if it does not exist.
- Handles run IDs, SLURM worker IDs, and random seed offsets.
- No physics.

OSPM_API.py
- Thin interface between the control layer and the daemon.
- Accepts a physics_engine(theta) callable.
- Starts the daemon loop.

OSPM_Daemon.py
- The search and optimization engine.
- Proposes parameter vectors (random or AI-biased).
- Calls the physics engine.
- Records all results to the deck CSV.
- Handles restarts, backups, stopping criteria, and AI control.
- Replaces the Fortran outer loop and grid logic.

OSPM_Physics.py
- Low-level spherical physics support.
- Halo density profiles (NFW / cored).
- Potential and force table construction.
- RK4 orbit integration and equations of motion.
- No chi², no data handling.

OSPM_Master.py
- The main physics driver.
- Builds the dynamics context for a given theta.
- Integrates orbits.
- Projects orbits into observables.
- Builds the A-matrix.
- Solves NNLS and computes chi².
- This replaces the Fortran OSPM master routine.

run_ospm.py
- Entry point for running OSPM.
- Loads the config.
- Preprocesses stellar data.
- Builds OSPMObservables once.
- Defines physics_engine(theta) using solve_ospm_theta.
- Starts the daemon via OSPM_API.

----------------------------------------------------------------
REQUIRED DATA AND DIRECTORY LAYOUT
----------------------------------------------------------------

profiles/<GALAXY>/data/<datafile>.csv
- Stellar data table.
- Must include RA, Dec, and line-of-sight velocity columns.

profiles/<GALAXY>/daemon_deck.csv
- Created automatically if missing.
- Persistent record of all tested parameter vectors and results.

Optional:
profiles/<GALAXY>/checkpoints/
- Backup copies of the deck CSV (if enabled).

----------------------------------------------------------------
WHAT YOU NEED TO RUN
----------------------------------------------------------------

Required Python packages:
- numpy
- pandas
- scipy
- torch
- astropy

No Fortran compilation is required.

Ensure the OSPM package directory is on PYTHONPATH.

----------------------------------------------------------------
HOW TO RUN
----------------------------------------------------------------

From the project root:

python run_ospm.py

This can be run locally or inside a SLURM job or job array.
Restarts are automatic.

----------------------------------------------------------------
WHAT HAPPENS DURING A RUN
----------------------------------------------------------------

1. Initial parameters are sampled within bounds.
2. Each parameter vector theta is passed to the physics engine.
3. solve_ospm_theta computes chi² via orbit integration and NNLS.
4. Results are appended to daemon_deck.csv.
5. After enough valid runs, AI-biased sampling activates.
6. The run stops when improvement stalls or limits are reached.

----------------------------------------------------------------
OUTPUTS
----------------------------------------------------------------

- daemon_deck.csv contains:
  * all tested parameter vectors
  * chi² values
  * rewards
  * status flags

- The best-fit parameters are printed to stdout at the end of the run.

----------------------------------------------------------------
RESTARTING OR EXTENDING A RUN
----------------------------------------------------------------

To resume or extend a run, simply rerun:

python run_ospm.py

The daemon continues from the existing deck automatically.

OSPM – Notes for Troubleshooting, Robustness, and Future Julia Port
===================================================================

This stack is intentionally left in a clear, inspectable state for debugging
and scientific validation. The notes below document known weak points and the
planned evolution path.

----------------------------------------------------------------
KNOWN LIMITATIONS / AREAS NEEDING ROBUSTNESS
----------------------------------------------------------------

1. Line-of-sight projection is a placeholder
- orbit_to_sigma2_profile() uses a crude LOS proxy.
- No true LOSVD, PSF convolution, or aperture integration.
- This is acceptable for pipeline validation, not for final science.
- Replace with full LOS machinery before production results.

2. Potential table construction is expensive
- tables_spherical() uses scipy quad at every radius.
- Recomputed for every theta.
- Correct but slow and sensitive to numerical tolerances.
- Should eventually use analytic expressions or cached tables.

3. No caching of halo tables across evaluations
- Identical or nearby theta values rebuild identical tables.
- Acceptable for debugging, inefficient for large runs.
- Table caching or memoization is a future optimization.

4. Orbit initial conditions are simplistic
- ic_sampler_SI is intentionally crude.
- Energy is not enforced self-consistently.
- Phase-space coverage is not controlled.
- Replace with physically motivated orbit libraries later.

5. Error handling is coarse-grained
- Physics failures are collapsed into numeric/orbit/unknown.
- Useful for automation but hides fine-grained diagnostics.
- Add optional verbose logging for debugging edge cases.

6. No axisymmetric or triaxial support
- Spherical-only by design at this stage.
- Geometry and force models must be generalized later.

----------------------------------------------------------------
WHAT SHOULD REMAIN IN PYTHON (BY DESIGN)
----------------------------------------------------------------

These parts benefit from Python’s flexibility and ecosystem and do not need
raw speed:

- Configuration (OSPM_Config)
- Control and runtime management (OSPM_Control, OSPM_API)
- Daemon logic, persistence, AI control (OSPM_Daemon)
- Data preprocessing and I/O
- Experiment orchestration and logging

These layers are I/O-bound or logic-bound, not compute-bound.

----------------------------------------------------------------
WHAT SHOULD MOVE TO JULIA (FOR SPEED)
----------------------------------------------------------------

These are the true performance bottlenecks and should be rewritten in Julia
once the physics is finalized.

1. Potential and force table construction
- build_R_halo_physical
- tables_spherical
- make_potential_force_funcs
- Julia can handle quadrature, interpolation, and caching much faster.
- Critical for large parameter sweeps.

2. Orbit integration
- derivs
- rk4_step
- integrate_orbit_rk4
- This is the dominant inner loop.
- Julia’s ODE tooling or custom integrators will be significantly faster.

3. Orbit library generation
- build_A_matrix inner loop
- Parallelizable across orbits and parameter sets.
- Ideal for Julia + multithreading or MPI.

4. Any future LOSVD machinery
- Histogramming, projections, and convolutions
- Performance-critical once implemented properly.

----------------------------------------------------------------
PLANNED EVOLUTION PATH
----------------------------------------------------------------

Phase 1: Current state
- Validate correctness.
- Debug physics and data flow.
- Ensure results are qualitatively sensible.

Phase 2: Physics stabilization
- Replace LOS proxy with real LOS machinery.
- Improve orbit IC sampling.
- Add diagnostic logging.

Phase 3: Julia backend
- Port OSPM_Physics and orbit loops to Julia.
- Expose a clean callable interface:
  chi2 = ospm_physics(theta, obs)
- Keep Python as the control and orchestration layer.

Phase 4: HPC scaling
- Parallel orbit libraries.
- Cached halo tables.
- Multi-galaxy batch runs.

----------------------------------------------------------------
DESIGN INTENT
----------------------------------------------------------------

This code is not optimized prematurely.
It is structured for clarity, traceability, and scientific trust first.

Speed comes later.
Correctness comes now.

